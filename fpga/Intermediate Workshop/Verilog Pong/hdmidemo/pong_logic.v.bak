// pong_logic.v â€” simple frame-rate updated Pong core
module pong_logic #(parameter H_ACTIVE=1280, V_ACTIVE=720) (
    input  wire        clk,
    input  wire        reset,
    input  wire        frame_start,
    input  wire        p1_up, p1_dn,
    input  wire        p2_up, p2_dn,
    output reg  [10:0] p1_y,
    output reg  [10:0] p2_y,
    output reg  [10:0] ball_x,
    output reg  [10:0] ball_y,
    output reg  [3:0]  score_l,
    output reg  [3:0]  score_r
);
    localparam PADDLE_H = 100;
    localparam PADDLE_W = 12;
    localparam BALL_S   = 10;
    localparam integer P1_X = 40;
    localparam integer P2_X = H_ACTIVE - 40 - PADDLE_W;

    // velocities (signed)
    reg signed [10:0] vx, vy;

    // init
    always @(posedge clk) begin
        if (reset) begin
            p1_y    <= (V_ACTIVE-PADDLE_H)/2;
            p2_y    <= (V_ACTIVE-PADDLE_H)/2;
            ball_x  <= H_ACTIVE/2;
            ball_y  <= V_ACTIVE/2;
            vx      <= 11'sd4;
            vy      <= 11'sd3;
            score_l <= 4'd0;
            score_r <= 4'd0;
        end else if (frame_start) begin
            // paddles
            if (p1_up && p1_y>0)                  p1_y <= p1_y - 6;
            else if (p1_dn && p1_y < V_ACTIVE-PADDLE_H) p1_y <= p1_y + 6;

            if (p2_up && p2_y>0)                  p2_y <= p2_y - 6;
            else if (p2_dn && p2_y < V_ACTIVE-PADDLE_H) p2_y <= p2_y + 6;

            // ball move
            ball_x <= ball_x + vx;
            ball_y <= ball_y + vy;

            // top/bottom bounce
            if (ball_y <= 0) begin
                ball_y <= 0; vy <= -vy;
            end else if (ball_y >= V_ACTIVE-BALL_S) begin
                ball_y <= V_ACTIVE-BALL_S; vy <= -vy;
            end

            // left paddle collision
            if (ball_x <= P1_X + PADDLE_W &&
                ball_x + BALL_S >= P1_X &&
                ball_y + BALL_S >= p1_y &&
                ball_y <= p1_y + PADDLE_H) begin
                ball_x <= P1_X + PADDLE_W;
                vx <= (vx < 0) ? -vx : vx; // ensure to the right
                // add a bit of english
                if (p1_up)  vy <= vy - 1;
                if (p1_dn)  vy <= vy + 1;
            end

            // right paddle collision
            if (ball_x + BALL_S >= P2_X &&
                ball_x <= P2_X + PADDLE_W &&
                ball_y + BALL_S >= p2_y &&
                ball_y <= p2_y + PADDLE_H) begin
                ball_x <= P2_X - BALL_S;
                vx <= (vx > 0) ? -vx : vx; // ensure to the left
                if (p2_up)  vy <= vy - 1;
                if (p2_dn)  vy <= vy + 1;
            end

            // score left/right
            if (ball_x == 0) begin
                score_r <= (score_r==9)? 0 : score_r + 1;
                ball_x  <= H_ACTIVE/2; ball_y <= V_ACTIVE/2; vx <=  11'sd4; vy <= 11'sd2;
            end else if (ball_x + BALL_S >= H_ACTIVE) begin
                score_l <= (score_l==9)? 0 : score_l + 1;
                ball_x  <= H_ACTIVE/2; ball_y <= V_ACTIVE/2; vx <= -11'sd4; vy <= 11'sd2;
            end
        end
    end
endmodule
