library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

-- Top-Level Integration Module
-- Combines all lab activities with non-overlapping resource usage
--
-- RESOURCE ALLOCATION:
-- Activity 1 (Full Adder):        SW[2:0]  -> LED[1:0]
-- Activity 2 (Switch to Display): SW[7:4]  -> HEX0
-- Activity 3 (Adder Display):     SW[2:0]  -> HEX1
-- Activity 4 (Binary to Decimal): SW[9:0]  -> HEX[5:2] (HEX5=Sign, HEX4=Hundreds, HEX3=Tens, HEX2=Ones)
--
-- Note: SW[2:0] is shared between Activity 1 and 3 (both use full adder inputs)

entity lab_integration is
    Port (
        SW : in STD_LOGIC_VECTOR(9 downto 0);      -- 10 switches
        LED : out STD_LOGIC_VECTOR(1 downto 0);    -- 2 LEDs for Activity 1
        HEX0 : out STD_LOGIC_VECTOR(6 downto 0);   -- Activity 2
        HEX1 : out STD_LOGIC_VECTOR(6 downto 0);   -- Activity 3
        HEX2 : out STD_LOGIC_VECTOR(6 downto 0);   -- Activity 4 - Ones
        HEX3 : out STD_LOGIC_VECTOR(6 downto 0);   -- Activity 4 - Tens
        HEX4 : out STD_LOGIC_VECTOR(6 downto 0);   -- Activity 4 - Hundreds
        HEX5 : out STD_LOGIC_VECTOR(6 downto 0)    -- Activity 4 - Sign
    );
end lab_integration;

architecture Behavioral of lab_integration is
    
    -- Component Declarations
    
    -- Activity 1: Full Adder
    component full_adder is
        Port (
            A : in STD_LOGIC;
            B : in STD_LOGIC;
            Cin : in STD_LOGIC;
            Sum : out STD_LOGIC;
            Cout : out STD_LOGIC
        );
    end component;
    
    -- Internal signals for Activity 3
    signal sum_internal : STD_LOGIC;
    signal cout_internal : STD_LOGIC;
    
    -- Function: Convert digit (0-9) to 7-segment display
    function digit_to_7seg(digit : integer) return STD_LOGIC_VECTOR is
        variable seg : STD_LOGIC_VECTOR(6 downto 0);
    begin
        case digit is
            when 0 => seg := "1000000"; -- 0
            when 1 => seg := "1111001"; -- 1
            when 2 => seg := "0100100"; -- 2
            when 3 => seg := "0110000"; -- 3
            when 4 => seg := "0011001"; -- 4
            when 5 => seg := "0010010"; -- 5
            when 6 => seg := "0000010"; -- 6
            when 7 => seg := "1111000"; -- 7
            when 8 => seg := "0000000"; -- 8
            when 9 => seg := "0010000"; -- 9
            when others => seg := "1111111"; -- Blank
        end case;
        return seg;
    end function;
    
    -- Function: Convert sign bit to 7-segment display
    function sign_to_7seg(sign_bit : STD_LOGIC) return STD_LOGIC_VECTOR is
        variable seg : STD_LOGIC_VECTOR(6 downto 0);
    begin
        if sign_bit = '1' then
            seg := "0111111"; -- Negative sign (-)
        else
            seg := "1111111"; -- Blank (positive)
        end if;
        return seg;
    end function;
    
begin
    
    -- ========================================
    -- ACTIVITY 1: Full Adder (SW[2:0] -> LED[1:0])
    -- ========================================
    FA1: full_adder
        port map (
            A => SW(0),
            B => SW(1),
            Cin => SW(2),
            Sum => LED(0),
            Cout => LED(1)
        );
    
    -- ========================================
    -- ACTIVITY 2: Switch to Display (SW[7:4] -> HEX0)
    -- ========================================
    process(SW)
        variable active_switch : integer range 0 to 15;
    begin
        active_switch := 0;
        
        -- Priority encoder: lowest index switch has priority
        if SW(4) = '1' then
            active_switch := 4;
        elsif SW(5) = '1' then
            active_switch := 5;
        elsif SW(6) = '1' then
            active_switch := 6;
        elsif SW(7) = '1' then
            active_switch := 7;
        else
            active_switch := 0; -- Default: show 0 when no switch is active
        end if;
        
        HEX0 <= digit_to_7seg(active_switch);
    end process;
    
    -- ========================================
    -- ACTIVITY 3: Full Adder with Display (SW[2:0] -> HEX1)
    -- ========================================
    -- Reuse the full adder logic from Activity 1
    FA2: full_adder
        port map (
            A => SW(0),
            B => SW(1),
            Cin => SW(2),
            Sum => sum_internal,
            Cout => cout_internal
        );
    
    -- Convert full adder result to 7-segment display
    process(sum_internal, cout_internal)
        variable result : integer range 0 to 3;
    begin
        result := to_integer(unsigned(cout_internal & sum_internal));
        HEX1 <= digit_to_7seg(result);
    end process;
    
    -- ========================================
    -- ACTIVITY 4: Binary to Decimal (SW[9:0] -> HEX[5:2])
    -- ========================================
    process(SW)
        variable temp_signed : integer range -512 to 511;
        variable temp_abs : integer range 0 to 512;
        variable temp : integer range 0 to 512;
        variable sign_bit : STD_LOGIC;
        variable hundreds, tens, ones : integer range 0 to 9;
    begin
        -- Convert input (signed 9-bit number with SW(9) as sign indicator)
        if SW(9) = '1' then
            temp_signed := to_integer(unsigned(SW(8 downto 0))) - 512;
        else
            temp_signed := to_integer(unsigned(SW(8 downto 0)));
        end if;
        
        -- Get the absolute value and sign
        if temp_signed < 0 then
            temp_abs := -temp_signed;
            sign_bit := '1';
        else
            temp_abs := temp_signed;
            sign_bit := '0';
        end if;
        
        -- Break into decimal digits
        temp := temp_abs;
        hundreds := temp / 100;
        temp := temp mod 100;
        tens := temp / 10;
        ones := temp mod 10;
        
        -- Assign to displays
        HEX2 <= digit_to_7seg(ones);      -- Ones place
        HEX3 <= digit_to_7seg(tens);      -- Tens place
        HEX4 <= digit_to_7seg(hundreds);  -- Hundreds place
        HEX5 <= sign_to_7seg(sign_bit);   -- Sign
    end process;
    
end Behavioral;


-- ========================================
-- ACTIVITY 1 COMPONENT: Full Adder
-- ========================================
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity full_adder is
    Port (
        A : in STD_LOGIC;
        B : in STD_LOGIC;
        Cin : in STD_LOGIC;
        Sum : out STD_LOGIC;
        Cout : out STD_LOGIC
    );
end full_adder;

architecture Behavioral of full_adder is
begin
    Sum <= A xor B xor Cin;
    Cout <= (A and B) or (A and Cin) or (B and Cin);
end Behavioral;