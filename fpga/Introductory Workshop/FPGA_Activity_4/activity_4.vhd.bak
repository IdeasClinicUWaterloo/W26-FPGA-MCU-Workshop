-- ========================================
-- ACTIVITY 4: activity_4.vhd
-- Binary to Decimal Conversion
-- 10-bit signed binary input -> Decimal display
-- ========================================
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY activity_4 IS
    PORT (
        SW   : IN  STD_LOGIC_VECTOR(9 DOWNTO 0);    -- 10 switches (SW9=sign, SW8:0=magnitude)
        HEX2 : OUT STD_LOGIC_VECTOR(6 DOWNTO 0);    -- Ones place
        HEX3 : OUT STD_LOGIC_VECTOR(6 DOWNTO 0);    -- Tens place
        HEX4 : OUT STD_LOGIC_VECTOR(6 DOWNTO 0);    -- Hundreds place
        HEX5 : OUT STD_LOGIC_VECTOR(6 DOWNTO 0)     -- Sign display
    );
END activity_4;

ARCHITECTURE Behavioral OF activity_4 IS
    
    -- Signals for intermediate values
    SIGNAL signed_val : INTEGER RANGE -512 TO 511;
    SIGNAL abs_val : INTEGER RANGE 0 TO 512;
    SIGNAL sign_bit : STD_LOGIC;
    SIGNAL hundreds : INTEGER RANGE 0 TO 9;
    SIGNAL tens : INTEGER RANGE 0 TO 9;
    SIGNAL ones : INTEGER RANGE 0 TO 9;
    
    -- Function: Convert digit (0-9) to 7-segment display
    FUNCTION digit_to_7seg(digit : INTEGER) RETURN STD_LOGIC_VECTOR IS
        VARIABLE seg : STD_LOGIC_VECTOR(6 DOWNTO 0);
    BEGIN
        CASE digit IS
            WHEN 0 => seg := "1000000"; -- 0
            WHEN 1 => seg := "1111001"; -- 1
            WHEN 2 => seg := "0100100"; -- 2
            WHEN 3 => seg := "0110000"; -- 3
            WHEN 4 => seg := "0011001"; -- 4
            WHEN 5 => seg := "0010010"; -- 5
            WHEN 6 => seg := "0000010"; -- 6
            WHEN 7 => seg := "1111000"; -- 7
            WHEN 8 => seg := "0000000"; -- 8
            WHEN 9 => seg := "0010000"; -- 9
            WHEN OTHERS => seg := "1111111"; -- Blank
        END CASE;
        RETURN seg;
    END FUNCTION;
    
    -- Function: Convert sign bit to 7-segment display
    FUNCTION sign_to_7seg(sign : STD_LOGIC) RETURN STD_LOGIC_VECTOR IS
        VARIABLE seg : STD_LOGIC_VECTOR(6 DOWNTO 0);
    BEGIN
        IF sign = '1' THEN
            seg := "0111111"; -- Negative sign (-)
        ELSE
            seg := "1111111"; -- Blank (positive)
        END IF;
        RETURN seg;
    END FUNCTION;
    
BEGIN
    
    -- Main process to handle input conversion
    PROCESS (SW)
        VARIABLE temp_signed : INTEGER RANGE -512 TO 511;
        VARIABLE temp_abs : INTEGER RANGE 0 TO 512;
        VARIABLE temp : INTEGER RANGE 0 TO 512;
    BEGIN
        -- Convert input (signed 9-bit number with SW(9) as sign indicator)
        IF SW(9) = '1' THEN
            temp_signed := TO_INTEGER(UNSIGNED(SW(8 DOWNTO 0))) - 512;
        ELSE
            temp_signed := TO_INTEGER(UNSIGNED(SW(8 DOWNTO 0)));
        END IF;
        
        signed_val <= temp_signed;
        
        -- Get the absolute value and sign
        IF temp_signed < 0 THEN
            temp_abs := -temp_signed;
            sign_bit <= '1';
        ELSE
            temp_abs := temp_signed;
            sign_bit <= '0';
        END IF;
        
        abs_val <= temp_abs;
        
        -- Break into decimal digits
        temp := temp_abs;
        hundreds <= temp / 100;
        temp := temp MOD 100;
        tens <= temp / 10;
        ones <= temp MOD 10;
        
    END PROCESS;
    
    -- Display outputs using helper functions
    HEX5 <= sign_to_7seg(sign_bit);      -- Sign display
    HEX4 <= digit_to_7seg(hundreds);     -- Hundreds place
    HEX3 <= digit_to_7seg(tens);         -- Tens place
    HEX2 <= digit_to_7seg(ones);         -- Ones place
    
END Behavioral;